diff --git a/backend/apps/inventory/models.py b/backend/apps/inventory/models.py
index 1234567..abcdefg 100644
--- a/backend/apps/inventory/models.py
+++ b/backend/apps/inventory/models.py
@@ -94,11 +94,20 @@ class Inventory(TimeStampedModel):
     @transaction.atomic
     def release(self, quantity):
         """
         Release reserved stock (e.g., when cart expires or item removed).
+
+        IMPORTANT: Each reservation must be released exactly once.
+        Do NOT call this after consume() - consume() already reduces reserved quantity.
         """
         inventory = Inventory.objects.select_for_update().get(pk=self.pk)
-        inventory.quantity_reserved = max(0, inventory.quantity_reserved - quantity)
+
+        # Defensive check: prevent negative reserved quantity
+        if quantity > inventory.quantity_reserved:
+            raise ValidationError(
+                f"Cannot release {quantity} units - only {inventory.quantity_reserved} reserved. "
+                f"Possible double-release detected for {self.sku.sku_code}"
+            )
+
+        inventory.quantity_reserved -= quantity
         inventory.save(update_fields=['quantity_reserved', 'updated_at'])

         return True
diff --git a/backend/apps/cart/models.py b/backend/apps/cart/models.py
index 2345678..bcdefgh 100644
--- a/backend/apps/cart/models.py
+++ b/backend/apps/cart/models.py
@@ -70,10 +70,26 @@ class Cart(TimeStampedModel):
         self.save(update_fields=['expires_at', 'updated_at'])

     @transaction.atomic
-    def clear(self):
-        """Remove all items and release reservations."""
+    def clear(self, release_reservations=True):
+        """
+        Remove all items from cart.
+
+        Args:
+            release_reservations: If True, release inventory reservations.
+                                 Set to False after checkout (consume already released).
+
+        USAGE:
+        - User clears cart: cart.clear(release_reservations=True) [default]
+        - After checkout: cart.clear(release_reservations=False)
+        - Expired cart cleanup: cart.clear(release_reservations=True) [default]
+        """
         for item in self.items.all():
-            item.delete()
+            if release_reservations:
+                item.release_and_delete()
+            else:
+                # Reservation already handled (e.g., consumed during checkout)
+                item.delete()


 class CartItem(TimeStampedModel):
@@ -169,8 +185,32 @@ class CartItem(TimeStampedModel):
         self.quantity = new_quantity
         self.save(update_fields=['quantity', 'updated_at'])

+    def release_and_delete(self):
+        """
+        Release inventory reservation and delete cart item.
+        Use this when user explicitly removes item from cart.
+
+        RESERVATION LIFECYCLE:
+        - User adds to cart: inventory.reserve() is called
+        - User removes from cart: call this method (release + delete)
+        - Checkout consumes: inventory.consume() then delete() without release
+        - Cart expires: release reservation then delete() without release
+        """
+        if hasattr(self.sku, 'inventory'):
+            self.sku.inventory.release(self.quantity)
+        self.delete()
+
     def delete(self, *args, **kwargs):
-        """Release inventory reservation when item is removed."""
-        if hasattr(self.sku, 'inventory'):
-            self.sku.inventory.release(self.quantity)
+        """
+        Delete cart item WITHOUT releasing reservation.
+
+        WARNING: This does NOT release inventory automatically.
+        Caller must explicitly release reservation if needed via:
+        - release_and_delete() for user removals
+        - inventory.release() before delete() for expirations
+        - inventory.consume() before delete() for checkout
+
+        This prevents double-release bugs where reservation is
+        released once explicitly and again implicitly.
+        """
         super().delete(*args, **kwargs)
diff --git a/backend/apps/cart/views.py b/backend/apps/cart/views.py
index 3456789..cdefghi 100644
--- a/backend/apps/cart/views.py
+++ b/backend/apps/cart/views.py
@@ -139,7 +139,8 @@ class CartViewSet(viewsets.ViewSet):
         try:
             with transaction.atomic():
                 if new_quantity == 0:
-                    # Remove item
+                    # Remove item (user-initiated, must release reservation)
-                    cart_item.delete()
+                    cart_item.release_and_delete()
                 else:
                     # Update quantity
                     cart_item.update_quantity(new_quantity)
@@ -174,7 +175,8 @@ class CartViewSet(viewsets.ViewSet):
         cart_item = get_object_or_404(CartItem, id=item_id, cart=cart)

         with transaction.atomic():
-            cart_item.delete()
+            # User-initiated removal, must release reservation
+            cart_item.release_and_delete()

         # Refresh cart data
         cart.refresh_from_db()
diff --git a/backend/apps/orders/views.py b/backend/apps/orders/views.py
index 4567890..defghij 100644
--- a/backend/apps/orders/views.py
+++ b/backend/apps/orders/views.py
@@ -135,7 +135,9 @@ class OrderViewSet(viewsets.ReadOnlyModelViewSet):
                 )

                 # Clear cart after successful checkout
-                cart.clear()
+                # Use release_reservations=False because consume() already handled it
+                cart.clear(release_reservations=False)
                 cart.delete()

         except Exception as e:
diff --git a/backend/apps/cart/tasks.py b/backend/apps/cart/tasks.py
index 5678901..efghijk 100644
--- a/backend/apps/cart/tasks.py
+++ b/backend/apps/cart/tasks.py
@@ -20,7 +20,8 @@ def cleanup_expired_carts():
     for cart in expired_carts:
         try:
             with transaction.atomic():
-                cart.clear()
+                # Clear with release_reservations=True (default) for expired carts
+                cart.clear(release_reservations=True)
                 cart.delete()
                 count += 1
         except Exception as e:
@@ -34,7 +35,12 @@ def cleanup_expired_carts():
 @shared_task
 def cleanup_expired_reservations():
     """
     Release expired cart item reservations.
     Runs more frequently than cart cleanup.
+
+    RESERVATION LIFECYCLE:
+    - Explicitly release reservation first
+    - Then delete item without re-releasing (prevents double-release)
     """
     from .models import CartItem

@@ -47,7 +53,8 @@ def cleanup_expired_reservations():
     for item in expired_items:
         try:
             with transaction.atomic():
-                # Release the reservation
+                # Release the reservation explicitly
                 if hasattr(item.sku, 'inventory'):
                     item.sku.inventory.release(item.quantity)

@@ -59,11 +66,13 @@ def cleanup_expired_reservations():
                         logger.info(f"Renewed reservation for cart item {item.id}")
                     except Exception:
                         # Can't re-reserve (out of stock), remove item
+                        # Delete without releasing (already released above)
                         item.delete()
                         logger.warning(f"Removed cart item {item.id} - stock unavailable")
                 else:
                     # Cart expired, remove item
+                    # Delete without releasing (already released above)
                     item.delete()

                 count += 1
diff --git a/backend/apps/cart/tests.py b/backend/apps/cart/tests.py
new file mode 100644
index 0000000..1234567
--- /dev/null
+++ b/backend/apps/cart/tests.py
@@ -0,0 +1,385 @@
+"""
+Tests for cart reservation lifecycle and double-release prevention.
+"""
+
+import pytest
+from django.test import TestCase
+from django.utils import timezone
+from django.core.exceptions import ValidationError
+from datetime import timedelta
+from apps.products.models import Product, SKU
+from apps.inventory.models import Inventory
+from apps.cart.models import Cart, CartItem
+from apps.core.exceptions import InsufficientStockError
+
+
+class InventoryReservationTestCase(TestCase):
+    """Test inventory reservation logic."""
+
+    def setUp(self):
+        """Create test product and SKU with inventory."""
+        self.product = Product.objects.create(
+            name="Test Card",
+            brand="Test TCG",
+            set_name="Test Set",
+            rarity=Product.Rarity.RARE,
+        )
+
+        self.sku = SKU.objects.create(
+            product=self.product,
+            condition=Product.Condition.NEAR_MINT,
+            language=Product.Language.EN,
+            is_foil=False,
+            price_cents=1000,
+        )
+
+        # Inventory is auto-created via signal
+        self.inventory = Inventory.objects.get(sku=self.sku)
+        self.inventory.quantity_on_hand = 10
+        self.inventory.save()
+
+    def test_reserve_reduces_available(self):
+        """Test that reserve() reduces available quantity."""
+        initial_available = self.inventory.quantity_available
+        self.inventory.reserve(3)
+        self.inventory.refresh_from_db()
+
+        self.assertEqual(self.inventory.quantity_reserved, 3)
+        self.assertEqual(self.inventory.quantity_available, initial_available - 3)
+
+    def test_release_increases_available(self):
+        """Test that release() increases available quantity."""
+        self.inventory.reserve(5)
+        self.inventory.refresh_from_db()
+
+        self.inventory.release(3)
+        self.inventory.refresh_from_db()
+
+        self.assertEqual(self.inventory.quantity_reserved, 2)
+        self.assertEqual(self.inventory.quantity_available, 8)
+
+    def test_release_prevents_negative_reserved(self):
+        """Test that release() prevents negative reserved quantity."""
+        self.inventory.reserve(3)
+        self.inventory.refresh_from_db()
+
+        # Try to release more than reserved
+        with self.assertRaises(ValidationError) as context:
+            self.inventory.release(5)
+
+        self.assertIn("double-release", str(context.exception).lower())
+
+    def test_consume_reduces_both_quantities(self):
+        """Test that consume() reduces both on_hand and reserved."""
+        self.inventory.reserve(5)
+        self.inventory.refresh_from_db()
+
+        initial_on_hand = self.inventory.quantity_on_hand
+        initial_reserved = self.inventory.quantity_reserved
+
+        self.inventory.consume(3)
+        self.inventory.refresh_from_db()
+
+        self.assertEqual(self.inventory.quantity_on_hand, initial_on_hand - 3)
+        self.assertEqual(self.inventory.quantity_reserved, initial_reserved - 3)
+
+    def test_consume_validates_reserved_quantity(self):
+        """Test that consume() validates against reserved quantity."""
+        self.inventory.reserve(3)
+        self.inventory.refresh_from_db()
+
+        # Try to consume more than reserved
+        with self.assertRaises(ValidationError) as context:
+            self.inventory.consume(5)
+
+        self.assertIn("only 3 reserved", str(context.exception))
+
+
+class CartItemReservationTestCase(TestCase):
+    """Test cart item reservation lifecycle."""
+
+    def setUp(self):
+        """Create test cart and product."""
+        self.product = Product.objects.create(
+            name="Test Card",
+            brand="Test TCG",
+            set_name="Test Set",
+            rarity=Product.Rarity.RARE,
+        )
+
+        self.sku = SKU.objects.create(
+            product=self.product,
+            condition=Product.Condition.NEAR_MINT,
+            language=Product.Language.EN,
+            is_foil=False,
+            price_cents=1000,
+        )
+
+        self.inventory = Inventory.objects.get(sku=self.sku)
+        self.inventory.quantity_on_hand = 20
+        self.inventory.save()
+
+        self.cart = Cart.objects.create(session_id="test-session-123")
+
+    def test_add_to_cart_reserves_inventory(self):
+        """Test that adding to cart reserves inventory."""
+        initial_available = self.inventory.quantity_available
+
+        # Reserve and create cart item
+        self.inventory.reserve(2)
+        cart_item = CartItem.objects.create(
+            cart=self.cart,
+            sku=self.sku,
+            quantity=2,
+        )
+
+        self.inventory.refresh_from_db()
+        self.assertEqual(self.inventory.quantity_reserved, 2)
+        self.assertEqual(self.inventory.quantity_available, initial_available - 2)
+
+    def test_release_and_delete_releases_once(self):
+        """Test that release_and_delete() releases reservation exactly once."""
+        # Create cart item with reservation
+        self.inventory.reserve(3)
+        cart_item = CartItem.objects.create(
+            cart=self.cart,
+            sku=self.sku,
+            quantity=3,
+        )
+
+        self.inventory.refresh_from_db()
+        reserved_before = self.inventory.quantity_reserved
+
+        # Use release_and_delete
+        cart_item.release_and_delete()
+
+        self.inventory.refresh_from_db()
+        self.assertEqual(self.inventory.quantity_reserved, reserved_before - 3)
+
+        # Verify cart item is deleted
+        self.assertFalse(CartItem.objects.filter(id=cart_item.id).exists())
+
+    def test_delete_without_release(self):
+        """Test that delete() does NOT release reservation."""
+        # Create cart item with reservation
+        self.inventory.reserve(3)
+        cart_item = CartItem.objects.create(
+            cart=self.cart,
+            sku=self.sku,
+            quantity=3,
+        )
+
+        self.inventory.refresh_from_db()
+        reserved_before = self.inventory.quantity_reserved
+
+        # Delete without release
+        cart_item.delete()
+
+        self.inventory.refresh_from_db()
+        # Reservation should still be there
+        self.assertEqual(self.inventory.quantity_reserved, reserved_before)
+
+    def test_update_quantity_adjusts_reservation(self):
+        """Test that update_quantity() properly adjusts reservation."""
+        # Create cart item
+        self.inventory.reserve(2)
+        cart_item = CartItem.objects.create(
+            cart=self.cart,
+            sku=self.sku,
+            quantity=2,
+        )
+
+        # Increase quantity
+        cart_item.update_quantity(5)
+
+        self.inventory.refresh_from_db()
+        self.assertEqual(self.inventory.quantity_reserved, 5)
+
+        # Decrease quantity
+        cart_item.update_quantity(3)
+
+        self.inventory.refresh_from_db()
+        self.assertEqual(self.inventory.quantity_reserved, 3)
+
+
+class CartClearTestCase(TestCase):
+    """Test cart.clear() with and without releasing reservations."""
+
+    def setUp(self):
+        """Create test cart with items."""
+        self.product = Product.objects.create(
+            name="Test Card",
+            brand="Test TCG",
+            set_name="Test Set",
+            rarity=Product.Rarity.RARE,
+        )
+
+        self.sku = SKU.objects.create(
+            product=self.product,
+            condition=Product.Condition.NEAR_MINT,
+            language=Product.Language.EN,
+            is_foil=False,
+            price_cents=1000,
+        )
+
+        self.inventory = Inventory.objects.get(sku=self.sku)
+        self.inventory.quantity_on_hand = 50
+        self.inventory.save()
+
+        self.cart = Cart.objects.create(session_id="test-session-123")
+
+        # Add items to cart
+        self.inventory.reserve(10)
+        self.cart_item = CartItem.objects.create(
+            cart=self.cart,
+            sku=self.sku,
+            quantity=10,
+        )
+
+    def test_clear_with_release_default(self):
+        """Test that clear() releases reservations by default."""
+        self.inventory.refresh_from_db()
+        reserved_before = self.inventory.quantity_reserved
+
+        self.cart.clear()  # Default: release_reservations=True
+
+        self.inventory.refresh_from_db()
+        self.assertEqual(self.inventory.quantity_reserved, 0)
+        self.assertEqual(self.cart.items.count(), 0)
+
+    def test_clear_with_release_explicit_true(self):
+        """Test clear(release_reservations=True) releases reservations."""
+        self.inventory.refresh_from_db()
+
+        self.cart.clear(release_reservations=True)
+
+        self.inventory.refresh_from_db()
+        self.assertEqual(self.inventory.quantity_reserved, 0)
+        self.assertEqual(self.cart.items.count(), 0)
+
+    def test_clear_without_release(self):
+        """Test clear(release_reservations=False) does NOT release."""
+        self.inventory.refresh_from_db()
+        reserved_before = self.inventory.quantity_reserved
+
+        self.cart.clear(release_reservations=False)
+
+        self.inventory.refresh_from_db()
+        # Reservation should still exist
+        self.assertEqual(self.inventory.quantity_reserved, reserved_before)
+        # But items should be deleted
+        self.assertEqual(self.cart.items.count(), 0)
+
+
+class CheckoutFlowTestCase(TestCase):
+    """Test checkout flow prevents double-release."""
+
+    def setUp(self):
+        """Create test cart ready for checkout."""
+        self.product = Product.objects.create(
+            name="Test Card",
+            brand="Test TCG",
+            set_name="Test Set",
+            rarity=Product.Rarity.RARE,
+        )
+
+        self.sku = SKU.objects.create(
+            product=self.product,
+            condition=Product.Condition.NEAR_MINT,
+            language=Product.Language.EN,
+            is_foil=False,
+            price_cents=1000,
+        )
+
+        self.inventory = Inventory.objects.get(sku=self.sku)
+        self.inventory.quantity_on_hand = 100
+        self.inventory.save()
+
+        self.cart = Cart.objects.create(session_id="test-session-123")
+
+        # Reserve and add to cart
+        self.inventory.reserve(5)
+        self.cart_item = CartItem.objects.create(
+            cart=self.cart,
+            sku=self.sku,
+            quantity=5,
+        )
+
+    def test_checkout_consume_then_clear_no_double_release(self):
+        """
+        Test that checkout flow (consume + clear) doesn't double-release.
+        This simulates the actual checkout flow.
+        """
+        self.inventory.refresh_from_db()
+        initial_on_hand = self.inventory.quantity_on_hand
+        initial_reserved = self.inventory.quantity_reserved
+
+        # Simulate checkout: consume inventory
+        self.inventory.consume(5)
+        self.inventory.refresh_from_db()
+
+        # After consume: on_hand reduced, reserved reduced
+        self.assertEqual(self.inventory.quantity_on_hand, initial_on_hand - 5)
+        self.assertEqual(self.inventory.quantity_reserved, initial_reserved - 5)
+
+        # Clear cart WITHOUT releasing (consume already did it)
+        self.cart.clear(release_reservations=False)
+
+        self.inventory.refresh_from_db()
+
+        # Verify no double-release occurred
+        self.assertEqual(self.inventory.quantity_on_hand, initial_on_hand - 5)
+        self.assertEqual(self.inventory.quantity_reserved, 0)  # Should be 0 after consume
+        self.assertEqual(self.cart.items.count(), 0)
+
+    def test_checkout_wrong_clear_would_fail(self):
+        """
+        Test that using clear(release_reservations=True) after consume would fail.
+        This demonstrates the bug we fixed.
+        """
+        self.inventory.refresh_from_db()
+        initial_reserved = self.inventory.quantity_reserved
+
+        # Consume inventory
+        self.inventory.consume(5)
+        self.inventory.refresh_from_db()
+
+        # After consume, reserved should be 0
+        self.assertEqual(self.inventory.quantity_reserved, 0)
+
+        # Try to clear with release=True (the bug!)
+        # This should raise ValidationError because there's nothing to release
+        with self.assertRaises(ValidationError) as context:
+            self.cart.clear(release_reservations=True)
+
+        self.assertIn("double-release", str(context.exception).lower())
+
+
+class ConcurrentReservationTestCase(TestCase):
+    """Test concurrent cart operations."""
+
+    def setUp(self):
+        """Create test product with limited stock."""
+        self.product = Product.objects.create(
+            name="Test Card",
+            brand="Test TCG",
+            set_name="Test Set",
+            rarity=Product.Rarity.RARE,
+        )
+
+        self.sku = SKU.objects.create(
+            product=self.product,
+            condition=Product.Condition.NEAR_MINT,
+            language=Product.Language.EN,
+            is_foil=False,
+            price_cents=1000,
+        )
+
+        self.inventory = Inventory.objects.get(sku=self.sku)
+        self.inventory.quantity_on_hand = 10  # Limited stock
+        self.inventory.save()
+
+    def test_insufficient_stock_prevents_oversell(self):
+        """Test that reservations prevent overselling."""
+        cart1 = Cart.objects.create(session_id="session-1")
+        cart2 = Cart.objects.create(session_id="session-2")
+
+        # Cart 1 reserves 6 items
+        self.inventory.reserve(6)
+        item1 = CartItem.objects.create(cart=cart1, sku=self.sku, quantity=6)
+
+        # Cart 2 tries to reserve 6 items (should fail - only 4 available)
+        with self.assertRaises(InsufficientStockError):
+            self.inventory.reserve(6)
+
+        # Cart 2 can reserve 4 items
+        self.inventory.reserve(4)
+        item2 = CartItem.objects.create(cart=cart2, sku=self.sku, quantity=4)
+
+        self.inventory.refresh_from_db()
+        self.assertEqual(self.inventory.quantity_reserved, 10)
+        self.assertEqual(self.inventory.quantity_available, 0)
+
+    def test_release_makes_stock_available_again(self):
+        """Test that releasing reservation makes stock available."""
+        cart = Cart.objects.create(session_id="test-session")
+
+        # Reserve all stock
+        self.inventory.reserve(10)
+        item = CartItem.objects.create(cart=cart, sku=self.sku, quantity=10)
+
+        self.inventory.refresh_from_db()
+        self.assertEqual(self.inventory.quantity_available, 0)
+
+        # Release some
+        self.inventory.release(4)
+
+        self.inventory.refresh_from_db()
+        self.assertEqual(self.inventory.quantity_available, 4)
+        self.assertEqual(self.inventory.quantity_reserved, 6)
